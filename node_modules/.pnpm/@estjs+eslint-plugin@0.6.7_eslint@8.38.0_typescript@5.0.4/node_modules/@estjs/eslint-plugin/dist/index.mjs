import { join } from 'node:path';
import { ESLintUtils } from '@typescript-eslint/utils';
import { createSyncFn } from 'synckit';
import { distDir } from './dirs.mjs';
import MagicString from 'magic-string';
import 'node:url';

const CLASS_FIELDS = ["class", "classname"];

const sortClasses$1 = createSyncFn(join(distDir, "worker-sort.cjs"));
const order = ESLintUtils.RuleCreator((name) => name)({
  name: "order",
  meta: {
    type: "layout",
    fixable: "code",
    docs: {
      description: "Order of Atomic CSS utilities in class attribute",
      recommended: "warn"
    },
    messages: {
      "invalid-order": "Atomic CSS utilities are not ordered"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    function checkLiteral(node) {
      if (typeof node.value !== "string") {
        return;
      }
      const input = node.value;
      const sorted = sortClasses$1(input);
      if (sorted !== input) {
        context.report({
          node,
          messageId: "invalid-order",
          fix(fixer) {
            return fixer.replaceText(node, `"${sorted.trim()}"`);
          }
        });
      }
    }
    const scriptVisitor = {
      JSXAttribute(node) {
        if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value && node.value.type === "Literal") {
          checkLiteral(node.value);
        }
      }
    };
    const templateBodyVisitor = {
      VAttribute(node) {
        if (node.key.name === "class" && node.value.type === "VLiteral") {
          checkLiteral(node.value);
        }
      }
    };
    if (context.parserServices == null || context.parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return context.parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const configsRecommended = {
  plugins: ["@estjs"],
  rules: {
    "@estjs/order": "warn",
    "@estjs/order-attributify": "warn",
    "@estjs/shorthand": "warn",
    "@estjs/unocss-shorthand": "off"
  }
};

const sortClasses = createSyncFn(join(distDir, "worker-sort.cjs"));
const INGORE_ATTRIBUTES = ["style", "class", "classname", "value"];
const orderAttributify = ESLintUtils.RuleCreator((name) => name)({
  name: "order-attributify",
  meta: {
    type: "layout",
    fixable: "code",
    docs: {
      description: "Order of Atomic CSS attributes",
      recommended: false
    },
    messages: {
      "invalid-order": "Atomic CSS attributes are not ordered"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const scriptVisitor = {};
    const templateBodyVisitor = {
      VStartTag(node) {
        const valueless = node.attributes.filter((i) => typeof i.key?.name === "string" && !INGORE_ATTRIBUTES.includes(i.key?.name?.toLowerCase()) && i.value == null);
        if (!valueless.length) {
          return;
        }
        const input = valueless.map((i) => i.key.name).join(" ").trim();
        const sorted = sortClasses(input);
        if (sorted !== input) {
          context.report({
            node,
            messageId: "invalid-order",
            fix(fixer) {
              const codeFull = context.getSourceCode();
              const offset = node.range[0];
              const code = codeFull.getText().slice(node.range[0], node.range[1]);
              const s = new MagicString(code);
              const sortedNodes = valueless.map((i) => [i.range[0] - offset, i.range[1] - offset]).sort((a, b) => b[0] - a[0]);
              for (const [start, end] of sortedNodes.slice(1)) {
                s.remove(start, end);
              }
              s.overwrite(sortedNodes[0][0], sortedNodes[0][1], ` ${sorted.trim()} `);
              return fixer.replaceText(node, s.toString());
            }
          });
        }
      }
    };
    if (context.parserServices == null || context.parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return context.parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const parserShort = createSyncFn(join(distDir, "parser-shorthand.cjs"));
const createShorthandRule$1 = ESLintUtils.RuleCreator((name) => name);
const shorthand = createShorthandRule$1({
  name: "shorthand",
  meta: {
    docs: {
      description: "Enforces the usage of shorthand Atomic CSS classnames",
      category: "Best Practices",
      recommended: true
    },
    fixable: "code",
    messages: {
      "invalid-shorthand": "Atomic CSS utilities are not shorthand"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const checkLiteral = (node) => {
      if (typeof node.value !== "string") {
        return;
      }
      const splitList = node.value.includes(")") ? node.value.split(/^(\S+?)\s+(\S+?)\s+(\S+?)\s+(.+)$/) : node.value.split(" ");
      const classList = Array.from(new Set(splitList || []));
      if (classList.length < 2) {
        return;
      }
      const { unused, used, genrate } = parserShort(classList);
      if (genrate.length > 0) {
        context.report({
          node,
          message: "Utility classes like {{className}} should be replaced ",
          data: { className: used.join(", ") },
          fix(fixer) {
            return fixer.replaceTextRange([node.range[0] + 1, node.range[1] - 1], [...genrate, ...unused].join(" "));
          }
        });
      }
    };
    const scriptVisitor = {
      JSXAttribute(node) {
        if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value && node.value.type === "Literal") {
          checkLiteral(node.value);
        }
      }
    };
    const templateBodyVisitor = {
      VAttribute(node) {
        if (node.key.name === "class" && node.value.type === "VLiteral") {
          checkLiteral(node.value);
        }
      }
    };
    if (context.parserServices == null || context.parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return context.parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const parserUnocssShort = createSyncFn(join(distDir, "unocss-shorthand.cjs"));
const createShorthandRule = ESLintUtils.RuleCreator((name) => name);
const unocssShorthand = createShorthandRule({
  name: "unocss-shorthand",
  meta: {
    docs: {
      description: "Enforces the usage of unocss shorthand Atomic CSS classnames",
      category: "Best Practices",
      recommended: true
    },
    fixable: "code",
    messages: {
      "invalid-shorthand": "Atomic CSS utilities are not unocss shorthand"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const checkLiteral = (node) => {
      if (typeof node.value !== "string") {
        return;
      }
      const splitList = node.value.includes(")") ? node.value.split(/^(\S+?)\s+(\S+?)\s+(\S+?)\s+(.+)$/) : node.value.split(" ");
      const classList = Array.from(new Set(splitList || []));
      if (classList.length < 2) {
        return;
      }
      const { unused, used, genrate } = parserUnocssShort(classList);
      if (genrate.length > 0) {
        context.report({
          node,
          message: "Utility classes like {{className}} should be replaced ",
          data: { className: used.join(", ") },
          fix(fixer) {
            return fixer.replaceTextRange([node.range[0] + 1, node.range[1] - 1], [...genrate, ...unused].join(" "));
          }
        });
      }
    };
    const scriptVisitor = {
      JSXAttribute(node) {
        if (typeof node.name.name === "string" && CLASS_FIELDS.includes(node.name.name.toLowerCase()) && node.value && node.value.type === "Literal") {
          checkLiteral(node.value);
        }
      }
    };
    const templateBodyVisitor = {
      VAttribute(node) {
        if (node.key.name === "class" && node.value.type === "VLiteral") {
          checkLiteral(node.value);
        }
      }
    };
    if (context.parserServices == null || context.parserServices.defineTemplateBodyVisitor == null) {
      return scriptVisitor;
    } else {
      return context.parserServices?.defineTemplateBodyVisitor(templateBodyVisitor, scriptVisitor);
    }
  }
});

const index = {
  rules: {
    order,
    "order-attributify": orderAttributify,
    "shorthand": shorthand,
    "unocss-shorthand": unocssShorthand
  },
  configs: {
    recommended: configsRecommended
  }
};

export { index as default };
